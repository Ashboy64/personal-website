---
title: 'Building a Lambda Calculus Interpreter in Rust'
date: '2025-06-28'
description: "Notes of functional programming and Rust's ownership system"
---

## Introduction

The early 20th century saw the discovery of paradoxes and inconsistencies in set theory, a foundational branch of mathematics on whose axioms and result the rest of the subject depends. These paradoxes led mathematicians to probe the nature of logic itself, and attempt to understand the limits of axiomatic knowledge and formal systems. The study of how logic, knowledge, and deduction could be formalized led to the invention of abstract systems of computation, and in turn, the field of computer science itself. Among the systems of computation developed to understand the nature of logic was the lambda calculus. Invented by Alonzo Church in the 1930s, the lambda calculus remains foundational to the theory of programming langauges, and forms the basis for modern functional languages like Haskell and OCaml.

I was first exposed to the lambda calculus during a programming languages course I took at college during fall 2024; this was probably my favorite course I ever took during my time at university. The first half of the course focused on foundational topics like the lamdba calculus and type theory, and the second half was more of a survey of some different modern programming languages. Among these was the Rust, which is growing increasingly popular, and features a unique type system designed to guarantee memory safety without the overhead of runtime garbage collection. I thought a fun way to revisit some of the concepts we covered in this course would be to build an interpreter for the lambda calculus in Rust, which is the main topic of the blog post you are now reading :)

## Appendix: The Lambda Calculus

### Syntax

A program in the lambda calculus is a single big _lambda expression_. A lambda expression is either:

- A _variable_, e.g. $x$.
- A _lambda abstraction_, e.g. $\lambda x. e$ where e is another lambda expression. Lambda abstractions define functions. For example, the program $\lambda x. x$ translates to "given any value $x$, return $x$"; it defines the identity function.
- A _function application_, e.g. $e_1 e_2$, where e_2 and e_2 are both lambda expressions.

A grammar for the lambda calculus can be given as:

$$
e -> x | \lambda x. e | e e | (e)
$$

Here is an example program in the lambda calculus:
$$
(\lambda z. (\lambda x. \lambda y. x) z) (\lambda a. a) ( \lambda b. \lambda c. c)
$$



A natural question to ask is: given such a program, how do we execute it?

### Execution

We execute lambda calculus programs by repeatedly rewriting the string in accordance to certain `computation rules'. For example, 

$$
\begin{align*}
    ((\lambda x. \lambda y. y x) & (\lambda a. a)) (\lambda b. b) \\
    & \rightarrow (\lambda y. y (\lambda a. a)) (\lambda b. b) \\
    & \rightarrow (\lambda b. b) (\lambda a. a) \\
    & \rightarrow \lambda a. a
\end{align*}
$$

We will define the final string we produce as a result of our computation rules (in this case $\lambda a. a$) to be the result of executing our program.

#### Beta Reduction

The most important computation rule of the lambda calculus is _beta reduction_. Beta reduction is a computation rule which says that when we have a lambda abstraction applied to some lambda expression, we should substitute the lambda expression for every occurrence of the lambda abstraction variable in the lambda abstraction body. We write this computation rule as:

$$
(\lambda x. e_1) e_2 \rightarrow e_1 [x := e_2]
$$

where $e_1 [x := e_2]$ represents our substitution operation. For a concrete example, consider the expression $(\lambda x. x) y$. We see that the expression is a function application, with the function $\lambda x. x$ being a lambda abstraction. Thus, this is an expression to which we can apply beta substitution. The output of beta substitution will just be $y$; we will substitute every occurrence of the formal parameter $x$ in the lambda abstraction body (which is just the variable $x$), so we are left with the output $y$. The program $(\lambda x. x) y$ thus evaluates to $y$, which makes intuitive sense because the program itself corresponds to applying the identity function on a variable $y$, which we expect to just give $y$ back as the output.

We can formally define our substitution operation $a [x := e]$ like so:

$$
\begin{align*}
    & x [x := e] = e \\
    & y [x := e] = y \\
    & (e_1 e_2) [x:=e] = (e_1 [x:=e]) (e_2 [x:=2]) \\
    & (\lambda x. e_1) [x:=e] = \lambda x. e_1 \\
    & (\lambda y. e_1) [x:=e] = \lambda y.(e_1 [x := e]) \text{ if x != y and y is not a free variable of $e$} \\
\end{align*}
$$

The last two cases require some elaboration. 

First, the rule $ (\lambda x. e_1) [x:=e] = \lambda x. e_1 $ specifies that if we are substituting a variable $x$ with $e$ in an expression $\lambda x. e_1$, we will not perform any edits to the expression because the lambda abstraction 'rebinds' the same variable. As an analogy, consider this C code:

```
int x = 0;

int add_one(int x) {
    return x + 1;
}
```

Since the function `add_one` takes in a variable $x$ as an argument, the value of the global variable $x$ does not effect the function's output. This kind of scoping is what the second-to-last rule reflect.

As for the last rule, consider the following program:

$$
(\lambda x. \lambda y. x y) y
$$

If we applied the rule without the condition "... if x != y and y is not a free variable of $e$", we would produce the following string:

$$
\lambda y. y y
$$

This string represents the program 'given some input y, return the output of applying y to itself'. However, this is _not_ what the original program actually represents. The value $y$ in our original program $(\lambda x. \lambda y. x y) y$ to which we applied $(\lambda x. \lambda y. x y)$ is a _free variable_; it is not bound by any lambda abstraction. We could have just as well called it $a$, or $very\_cool\_variable$, or $abracadabra$. If we called it $a$, we would produce the following result:

$$
\begin{align*}
    (\lambda x. &\lambda y. x y) a \\
    &\rightarrow \lambda y. x a
\end{align*}
$$

This result has an entirely different meaning than $\lambda y. y y$, the string we obtain if we 'naively' applied the substitution. The problem is that in the naive case, the expression we are substituting $x$ for contains free variables that are bound by inner lambda abstractions of the expression we are substituting into. 


#### Alpha Conversion